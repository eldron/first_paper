#include "mm.h"
#include "byteorder.h"
#include "cache.h"
#include <gmac.h>
#include "ffwd_msg.h"
#include "ffwd_debug.h"
#include "ffwd.h"
#include "stlc_list.h"
#include "mdio.h"
session_desc_t *dma_node;

dma_pkt_t dma_pkt_array[MAX_SESSION_PKT];
dma_pkt_t * dma_pkt_array_ptr;

u32 channel_offset[MAX_NUM_RX_CHANNELS] __shared_memory__;
//接收队列暂停标志
uint8_t rx_queue_pause[MAX_NUM_RX_CHANNELS] __shared_memory__;
//分发向量
int pde_vc[128] __shared_memory__;

//接收队列暂停标志
ffwd_counter_info_t *counter_base;

/* For traffic rate. */
uint32_t nowtime = 0;
uint32_t lasttime = 0;

static inline session_desc_t *session_node_malloc()
{
	session_desc_t *tmp;

	tmp = session_desc_head;
	if (tmp) {		
		session_desc_head = tmp->next;		
		tmp->next = NULL;
		FFWD_DBG(FFWD_DBG_DEBUG, "malloc session node %p\n", tmp);
	} 	
	return tmp;
}
static inline void session_node_free(session_desc_t *p)
{
	p->next = session_desc_head;
	session_desc_head = p;
}

void ffwd_pde_vc_update()
{
    int count = 0;
    int pos = 0;

    uint8_t mask = ffwd_device_info->pde_mask;

    // 0-7 bit 表示通道号,8bit表示更新
    if(ffwd_device_info->pde_reset)
    {
        printk("set pde_mask = %02x\n", mask);
        while(count < 128)
        {
            if((mask >> pos) & 0x1)
            {
                pde_vc[count] = pos;
                count += 1;
            }
            pos = (pos + 1) & (MAX_NUM_SESSION_CHANNELS - 1); 
        }
        ffwd_device_info->pde_reset = 0;
        
    }
}


#define MAC_PKT_SIZE 2048

int rx_offset;
int tx_offset;

static inline void ffwd_mac_interrupt_host(void)
{
	phoenix_reg_t *pcie_ctrl_mmio = 0;
    uint32_t val = 0;

	pcie_ctrl_mmio = phoenix_io_mmio(PHOENIX_IO_PCIE_1_OFFSET);
    FFWD_DBG(FFWD_DBG_DEBUG, "Trigger an MSI to the host\n");

	/* Trigger an MSI to the host */
     pcie_ctrl_mmio[0x07] = 0x01;
	 pcie_ctrl_mmio[0x06] = 0x20;

    do
    {
    	val = pcie_ctrl_mmio[0x07];
    }while(!val);
}

mac_packet_t * ffwd_alloc_mac_pkt()
{
	if(!stlc_list_empty(&mac_pkt_pool))
	{	
	    mac_packet_t *pkt = stlc_list_first_entry(&mac_pkt_pool, mac_packet_t, list);
		stlc_list_del(&(pkt->list));
		return pkt;
	}
	return NULL;
}

static inline void ffwd_free_mac_pkt(u64 msg, int srcid)
{
	mac_packet_t *pkt = (mac_packet_t *)((u32)phys_to_virt((u32)GET_RX_MSG_DATA(msg)) & MASK_2K_ALIGN);
	stlc_list_add_tail(&pkt->list, &mac_pkt_pool);

	FFWD_DBG(FFWD_DBG_DEBUG,"free xmit mac_packet= %p\n", pkt);
}

int ffwd_mac_rx()
{	
    uint8_t*    recv_data;
	uint16_t    pkt_len;
	uint32_t    daddr; 
	uint32_t    ret;
	
	uint32_t    srcid;
	uint64_t    msg;
	
    int recv_bkt = BUCKET_RCV_PKT;

	printk("pid%02d: starting mac rx task recv_bkt = %d\n", process_id,recv_bkt);
	
	while(1)
	{	
		if (ffwd_message_receive_fast_1(recv_bkt, srcid, msg) != 0)
			continue;

		FFWD_DBG(FFWD_DBG_DEBUG,"srcid %u recv msg %llx\n", srcid, msg);
				
		recv_data = (uint8_t* )phys_to_virt(( uint32_t )GET_RX_MSG_DATA(msg));
		pkt_len = GET_RX_MSG_LEN(msg) - CRC_SIZE;

		if (ffwd_mac_entry_desc_rx[rx_offset].state == FIFO_WRITABLE)
		{
			daddr = __swab32(ffwd_mac_entry_desc_rx[rx_offset].address);
		} 
		else
		{
		    FFWD_DBG(FFWD_DBG_DEBUG,"FIFO Not FIFO_WRITABLE ffwd_mac_entry_desc_rx[%d].state = %d\n",rx_offset,
		    ffwd_mac_entry_desc_rx[rx_offset].state);
		    SMA_COUNTER_INC(gmac0_rx_dropped_packets);
			goto cleanup;
		}
		
		FFWD_DBG(FFWD_DBG_DEBUG, "send paddr %llx, len %u to dma %u\n", virt_to_phys(recv_data), pkt_len, PCIE_RX_BUCKET_ID);
		ffwd_msg_send_to_dma(1, igrid_to_bucket[process_id], virt_to_phys(recv_data), daddr,pkt_len, 1, PCIE_RX_BUCKET_ID);
		
		ret = wait_dma_rsp_msg();
		if (ret == 0)
		{
            ffwd_mac_counter->rx_packets++;
            ffwd_mac_counter->rx_bytes += pkt_len;
            ffwd_mac_entry_desc_rx[rx_offset].len = __swab16(pkt_len);
			ffwd_mac_entry_desc_rx[rx_offset].state = FIFO_READABLE;	
            SMA_COUNTER_INC(gmac0_rx_packets);

			//if(ffwd_mac_device_info->msi_enable)
			//print_pkt(recv_data,pkt_len);
			
			ffwd_mac_interrupt_host();
			    
			rx_offset = (rx_offset + 1) & (MAC_ENTRY_DESC_NUM -1);
			barrier();
		}
cleanup:
		msg = FMN_MAKE_FREE_MSG(FMN_MSG_NOFREE_FBID,virt_to_phys(recv_data));			
		barrier();
		message_send_block_fast_1(0,MSGRNG_STNID_GMAC0_FR, msg);
	}
    return 0;
}


int ffwd_mac_tx()
{
	int free_bkt = BUCKET_RCV_RSP;
	mac_packet_t *pkt;
	u64 msg;
	u16 len;
	u32 addr;
	u32 srcid;

	printk("pid%02d: starting mac tx task recv_bkt = %d\n", process_id,free_bkt);
	
	while(1)
	{
	
		if (ffwd_message_receive_fast_1(free_bkt, srcid, msg) == 0)
		{
			FFWD_DBG(FFWD_DBG_DEBUG, "recv srcid %u free back msg.\n", srcid);
			ASSERT((srcid == MSGRNG_STNID_GMAC0));
			ffwd_free_mac_pkt(msg, srcid);
			continue;
		}

		if (ffwd_mac_entry_desc_tx[tx_offset].state == FIFO_READABLE)//需要传输
		{
			len = __swab16(ffwd_mac_entry_desc_tx[tx_offset].len);
			addr = __swab32(ffwd_mac_entry_desc_tx[tx_offset].address);

			pkt = ffwd_alloc_mac_pkt();
			if(pkt == NULL)
			    continue;
			    
			//pkt->len = len;

		    //printk("data_ptr = %p\n",pkt->data);
			ffwd_msg_send_to_dma(TRUE, igrid_to_bucket[process_id], addr, 
				virt_to_phys(pkt->data), len, 1, PCIE_TX_BUCKET_ID);
			wait_dma_rsp_msg();
			
            barrier();
                        

		    //print_pkt(pkt->data,len);
		    
			ffwd_mac_counter->tx_packets ++;
			ffwd_mac_counter->tx_bytes += len;
			ffwd_mac_entry_desc_tx[tx_offset].state = FIFO_WRITABLE;
			tx_offset = (tx_offset + 1) & (MAC_ENTRY_DESC_NUM - 1);
			msg = FMN_MAKE_TX_MSG(FMN_MSG_EOF, igrid_to_bucket[process_id], len, virt_to_phys(pkt->data));

            FFWD_DBG(FFWD_DBG_DEBUG, "xmit entry[%d] = %d , len = %d ,address = %08x\n",
                tx_offset,ffwd_mac_entry_desc_tx[tx_offset].state,len,addr);
            //printk("xmit entry[%d] = %d , len = %d ,address = %08x\n",
            //    tx_offset,ffwd_mac_entry_desc_tx[tx_offset].state,len,addr);
			barrier();
			
			if (ffwd_message_send_1(MSGRNG_STNID_GMAC0_TX0, msg))
			{
				SMA_COUNTER_INC(gmac0_tx_dropped_packets);
				FFWD_DBG(FFWD_DBG_DEBUG, "send faild\n");
			}
			else
			{
			    SMA_COUNTER_INC(gmac0_tx_packets);
			    FFWD_DBG(FFWD_DBG_DEBUG, "send ok\n");
			}

		}
	}
    return 0;
}

static inline void print_session_node(session_desc_t *node)
{
	xls_packet_t *tmp = node->req_pkt_head;
	FFWD_DBG(FFWD_DBG_DEBUG,"req direction: ------------------------------\n");
	while(tmp)
	{
		FFWD_DBG(FFWD_DBG_DEBUG,"NO: %02u [seq: 0x%x, nseq: 0x%x, ack: %10x, flag 0x%02x]\n", 
			tmp->de_num, tmp->seq, tmp->nseq, tmp->ack, tmp->th_flags);
		tmp = tmp->next_pkt;
	}
	FFWD_DBG(FFWD_DBG_DEBUG, "\n");
	
	tmp = node->rsp_pkt_head;
	FFWD_DBG(FFWD_DBG_DEBUG,"rsp direction: ------------------------------\n");
	while(tmp)
	{
		FFWD_DBG(FFWD_DBG_DEBUG,"NO: %02u [seq: 0x%x, nseq: 0x%x, ack: %10x flag 0x%02x]\n", 
			tmp->de_num, tmp->seq, tmp->nseq, tmp->ack, tmp->th_flags);
		tmp = tmp->next_pkt;
	}
	FFWD_DBG(FFWD_DBG_DEBUG,"\n");
}

static inline void print_merged_session_node(session_desc_t *node)
{
	xls_packet_t *tmp = node->pkt;
	FFWD_DBG(FFWD_DBG_DEBUG,"merged session relation: ------------------------------\n");
	while(tmp)
	{
		FFWD_DBG(FFWD_DBG_DEBUG,"NO: %02u [seq: 0x%x, nseq: 0x%x, ack: %10x flag 0x%02x], pay_len: %d\n", 
			tmp->de_num, tmp->seq, tmp->nseq, tmp->ack, tmp->th_flags, tmp->data_len);
		tmp = tmp->next_pkt;
	}
	FFWD_DBG(FFWD_DBG_DEBUG,"\n");
}

void ffwd_drop_session_node(session_desc_t *node)
{
	xls_packet_t *tmp = node->pkt;

	while(tmp)
	{
		drop_session_pkt(tmp);
		tmp = tmp->next_pkt;
	}

	session_node_free(node);
}

static inline void ffwd_recv_time_out_msg(u8 code, u64 msg);
void ffwd_session_dma_done();

static inline int dma_resp(u64 msg)
{
	uint32_t pcie_err=0 ;
	uint32_t iob_err=0 ;
	uint32_t msg_err=0 ;
	uint32_t flush=0 ;
	uint32_t tag_id=0 ;

	tag_id   = (msg) & 0x3ff;
	pcie_err = (msg >> 10) & 0x1;
	iob_err  = (msg >> 11) & 0x1;
	msg_err  = (msg >> 12) & 0x1;
	flush    = (msg >> 13) & 0x1;

	if ( (pcie_err > 0) || (iob_err > 0) || (msg_err > 0) || (flush > 0) ) 
	{
		FFWD_DBG(FFWD_DBG_ERR,"Error bit set for return msg tagId:0x%x  pcie_err:0x%x iob_err:0x%x msg_err:0x%x flush:0x%x \n",
	           tag_id, pcie_err, iob_err, msg_err, flush);
		return -1;
	}
	return 0;
}

int wait_dma_rsp_msg()
{
	int recv_bucket = BUCKET_RCV_RSP;
  	int srcid = 0;
	u64 msg = 0;

	while(1)
	{
		//msgrng_wait(1 << recv_bucket);	//调试用
		if(ffwd_message_receive_fast_1(recv_bucket, srcid, msg))
			continue;
		if (srcid == PCIE_RX_BUCKET_ID)
		{
			FFWD_DBG(FFWD_DBG_DEBUG, "recv dma rsp msg, srcid %d\n", srcid);
			return dma_resp(msg);
		}
		else if (srcid == MSGRNG_STNID_GMAC0 || srcid == MSGRNG_STNID_GMAC1)
		{
			FFWD_DBG(FFWD_DBG_DEBUG,"recv free back msg..............\n");
		}
		else if (srcid == MSGRNG_STNID_CPU0)
		{
			FFWD_DBG(FFWD_DBG_DEBUG, "recv timeout msg, srcid %d\n", srcid);
			ffwd_recv_time_out_msg(0, msg);
		}
		else
		{
			FFWD_DBG(FFWD_DBG_ERR, "recv unkown msg, srcid %d\n", srcid);
			return ERROR;
		}
	}
	
}

void static inline ffwd_msg_build_dma(int is_return, int return_bucket, struct msgrng_msg *msgsend,
           uint64_t src_addr, uint64_t dest_addr, unsigned int tid, int len)
{
        msgsend->msg0 = src_addr;
        msgsend->msg0 |= ((uint64_t)tid)  <<40;
        msgsend->msg0 |= (uint64_t)return_bucket <<50;
        msgsend->msg0 |= (u64)is_return <<57;
        msgsend->msg0 |= 0ULL <<58;
  /*      if (tid &0x1)
          msgsend->msg0 |= 0ULL <<59;
        else */
        msgsend->msg0 |= 1ULL <<59;
        msgsend->msg0 |= 0ULL <<60;

        msgsend->msg1 = (unsigned long)dest_addr;
        msgsend->msg1 |= ((unsigned long long) len << 40);
        msgsend->msg1 |= 0ULL<<60;
        msgsend->msg1 |= 0ULL<<62;
        msgsend->msg1 |= 0ULL<<63;

}

static __inline__ int ffwd_msg_send_to_dma(int is_return, int fr_stid, 
         uint64_t src_paddr, uint64_t dest_paddr, unsigned int len, 
	 int trans_id, int channel)
{
	struct msgrng_msg msg;
	int stid ;
	uint32_t dest;
	int ret;
	int i = 0;

	//dma_set_inform_src(SIMPLE_XFER, 1);
	ASSERT(len);

#if 0
	stid = dma_make_desc_tx(fr_stid, &msg, SIMPLE_XFER,
	                      src_paddr, dest_paddr, trans_id, len);
#endif
	ffwd_msg_build_dma(is_return, fr_stid, &msg, src_paddr, dest_paddr, 
		  				trans_id, len);
	stid = channel;
	/* Send the packet to DMA */
	/* Note: We need to send only two words for dma simple_xfer */
	//while (message_send(2, MSGRNG_CODE_DMA, stid, &msg));
	dest = (1<<16)|(stid);
//	while(message_push(dest, &msg));
	while(i<2048)
	{
		i++;
		ret = message_push(dest, &msg);
		if(ret == 0)
			break;
	}
	if (ret)
		FFWD_DBG(FFWD_DBG_ERR,"send msg0 %llx msg1 %llx to stid %d error no %d\n", msg.msg0, msg.msg0, stid, ret);
	else
		FFWD_DBG(FFWD_DBG_DEBUG,"send msg %llx msg1 %llx to stid %d OK, fr_stid %d \n", msg.msg0, msg.msg1, stid, fr_stid);

	return ret;
}

#define MHASH_GOLDEN_RATIO	0x9e3779b9
#define session_hash(key) \
(((key)->dip^(key)->sip^(key)->sport^(key)->dport^MHASH_GOLDEN_RATIO) & (MAXNUM_FLOW_BUCKET -1))


//需要比较上下行两个方向
static inline int __pkt_session_cmp(session_desc_t *node, session_key_t *key)
{   
	FFWD_DBG(FFWD_DBG_DEBUG,"dip,sip,dport,sport : node[0x%08x: 0x%08x: 0x%04x: 0x%04x], key[0x%08x: 0x%08x: 0x%04x: 0x%04x]\n",
		node->key.dip, node->key.sip,node->key.dport, node->key.sport, key->dip,  key->sip, key->dport, key->sport);
    if (node->key.dip== key->dip 
    	&& node->key.sip== key->sip 
    	&& node->key.dport== key->dport
    	&& node->key.sport== key->sport)
    {
        return 0;
    } 
	else if (node->key.dip== key->sip 
				&& node->key.sip== key->dip 
				&& node->key.dport== key->sport
				&& node->key.sport== key->dport)
    {
		return 0;
	}
	
    return -1;
}

//会话节点的比较只需要比较一个方向
static inline int __session_cmp(session_desc_t *node, session_key_t *key)
{   
	FFWD_DBG(FFWD_DBG_DEBUG,"dip,sip,dport,sport- node[0x%08x: 0x%08x: 0x%04x: 0x%04x], key[0x%08x: 0x%08x: 0x%04x: 0x%04x]\n",
		node->key.dip, node->key.sip,node->key.dport, node->key.sport, key->dip,  key->sip, key->dport, key->sport);
    if (node->key.dip== key->dip 
    	&& node->key.sip== key->sip 
    	&& node->key.dport== key->dport
    	&& node->key.sport== key->sport)
    {
        return 0;
    } 
	
    return -1;
}

//note 需要加锁
static inline session_desc_t *pkt_find_session_node(xls_packet_t *pkt)
{
    session_desc_t *node = NULL;
    struct stlc_hlist_node *tmp = NULL;

	spin_lock((spinlock_t *)&(session_bkt[pkt->hash].lock));
    stlc_hlist_for_each_entry(node, tmp, &(session_bkt[pkt->hash]), nd_hlist)
    {
        if (0 == __pkt_session_cmp(node, &pkt->key))
        {
        	FFWD_DBG(FFWD_DBG_DEBUG, "find node %p\n", node);
        	spin_unlock((spinlock_t *)&(session_bkt[pkt->hash].lock));
            return node;
        }
    }
	spin_unlock((spinlock_t *)&(session_bkt[pkt->hash].lock));
    return NULL;
}

//note 需要加锁
static inline session_desc_t *session_node_del(session_desc_t *entry)
{
    session_desc_t *node = NULL;
    struct stlc_hlist_node *tmp = NULL;

	spin_lock((spinlock_t *)&(session_bkt[entry->hash].lock));
    stlc_hlist_for_each_entry(node, tmp, &(session_bkt[entry->hash]), nd_hlist)
    {
        if (0 == __session_cmp(node, &entry->key))
        {
        	FFWD_DBG(FFWD_DBG_DEBUG, "find and del node %p\n", node);
        	stlc_hlist_del(&(node->nd_hlist));
        	spin_unlock((spinlock_t *)&(session_bkt[entry->hash].lock));
            return node;
        }
    }
	spin_unlock((spinlock_t *)&(session_bkt[entry->hash].lock));
    return NULL;
}

session_desc_t * session_node_create( xls_packet_t *pkt)
{
	session_desc_t *node;
	u32 hash = pkt->hash;

	node = session_node_malloc();
	if (node == NULL)
		return NULL;
	memset(node,0,sizeof(session_desc_t));

	node->key.dip = pkt->key.dip;
	node->key.sip = pkt->key.sip;
	node->key.dport = pkt->key.dport;
	node->key.sport = pkt->key.sport;
	node->protocol = pkt->protocol;
	node->hash = pkt->hash;
	node->pid = process_id;
	node->timer_tick = now;
	
	spin_lock((spinlock_t *)&(session_bkt[hash].lock));
    stlc_hlist_add_head(&(node->nd_hlist), &(session_bkt[hash]));
    spin_unlock((spinlock_t *)&(session_bkt[hash].lock));
    SMA_COUNTER_INC(gmac1_active_sessions);

    return node;
}

//合并同一会话上下行报文
static inline void merge_two_diections_pkt(session_desc_t *node)
{
	xls_packet_t *cp = NULL;
	xls_packet_t *sp =NULL;
	xls_packet_t *tmp = NULL, *head = NULL;

	ASSERT(node);
	
	cp= node->req_pkt_head;
	sp = node->rsp_pkt_head;

	if (cp && !sp)          
	{
	    //下行报文为空,合并后的报文直接指向上行
		node->pkt = cp;
		return ;
	}
	else if (!cp && sp)
	{	
	    //上行报文为空,合并后的报文直接指向下行
	    node->pkt = sp;
		return ;
	}
	else if (cp && sp)
	{
		if (cp->ack > sp->seq)//选择头节点
		{
			head = tmp = sp;
			sp = sp->next_pkt;
		}
		else 
		{
			head = tmp = cp;
			cp = cp->next_pkt;
		}
	}
	else 
	{
	    //上下行报文都为空
		node->pkt = NULL;
		return;
	}

	while(cp && sp)
	{
		if (cp->ack > sp->seq)//下行在前
		{
			tmp->next_pkt = sp;
			tmp = sp;
			sp = sp->next_pkt;
		}
		else
		{
			tmp->next_pkt = cp;
			tmp = cp;
			cp = cp->next_pkt;
		}
	}

	if (tmp != NULL)
		tmp->next_pkt = cp ? cp : sp;

	node->pkt = head;
}

static inline void insert_pkt2session(xls_packet_t *pkt,session_desc_t *node)
{
	xls_packet_t *tmp;
	
	if (pkt->data_len == 0||pkt->th_flags & (TH_FIN|TH_RST))
		goto cleanup;

	node->pkt_num += 1;
	node->total_paylen += pkt->data_len;

#if 1
	if (pkt->direction == REQ_DIRECT)
	{
		tmp = node->req_pkt_tail;
		if (tmp == NULL)//如果当前方向还未插入报文,直接插入当前报文为此方向头报文
		{
			node->req_pkt_head = node->req_pkt_tail = pkt;
			return;
		}
		else if (tmp->seq < pkt->seq)//当前报文序列号大于会话节点尾报文的序列号，直接插入在尾部(顺序报文都是这种情况))
		{
			tmp->next_pkt = pkt;
			node->req_pkt_tail = pkt;
			FFWD_DBG(FFWD_DBG_DEBUG,"pkt->seq %d tail seq %d\n", pkt->seq, tmp->seq);
			return ;
		}
		else if (tmp->seq == pkt->seq)
		{
		    //重传报文
			node->pkt_num -= 1;
			node->total_paylen -= pkt->data_len;
			goto cleanup;
		}
		else//如果当前报文序列号小于会话节点尾报文的序列号，需要从链表头按序插入(乱序情况)
		{
		    //乱序报文
			tmp = node->req_pkt_head;
			if (tmp->seq > pkt->seq)//比头报文序列号还小，替换头报文
			{
				pkt->next_pkt = tmp;
				node->req_pkt_head = pkt;
				return;
			}
		}
	}
	else
	{
		tmp = node->rsp_pkt_tail;
		if (tmp == NULL)//如果当前方向还未插入报文,直接插入当前报文为此方向头报文
		{
			node->rsp_pkt_head = node->rsp_pkt_tail = pkt;
			return;
		}
		else if (tmp->seq < pkt->seq)//当前报文序列号大于会话节点尾报文的序列号，直接插入在尾部(顺序报文都是这种情况))
		{
			tmp->next_pkt = pkt;
			node->rsp_pkt_tail = pkt;
			FFWD_DBG(FFWD_DBG_DEBUG,"pkt->seq %d tail seq %d\n", pkt->seq, tmp->seq);
			return ;
		}
		else if (tmp->seq == pkt->seq)
		{
			node->pkt_num -= 1;
			node->total_paylen -= pkt->data_len;
			goto cleanup;
		}
		else//如果当前报文序列号小于会话节点尾报文的序列号，需要从链表头按序插入(乱序情况)
		{
			tmp = node->rsp_pkt_head;
			if (tmp->seq > pkt->seq)//比头报文序列号还小，替换头报文
			{
				pkt->next_pkt = tmp;
				node->rsp_pkt_head = pkt;
				return;
			}
		}
	}

	//在链表中间插入的情况
	while(tmp->next_pkt)
	{
		if (tmp->next_pkt->seq > pkt->seq)
		{
			if (tmp->seq == pkt->seq)
			{
				node->pkt_num -= 1;
				node->total_paylen -= pkt->data_len;
				goto cleanup;
			}
			else 
			{
				pkt->next_pkt = tmp->next_pkt;
				tmp->next_pkt = pkt;
				break;
			}
		}
		else
			tmp = tmp->next_pkt;	
	}

	if (tmp->next_pkt == NULL)
	{
	    //ffwd_dbg_level = 4;
		FFWD_DBG(FFWD_DBG_ERR, "error: can't insert into session node seq = %08x\n",pkt->seq);
		print_session_node(node);
		//ffwd_dbg_level = 1;
		goto cleanup;
	}
#endif 
	return;
cleanup:
	SMA_COUNTER_INC(gmac1_session_dis_packets);
	drop_session_pkt(pkt);
	return;
}

//TCP 通道处理函数
void ffwd_session_pkt_input(xls_packet_t *pkt)
{
    //不带数据且不是会话结束标志的报文丢弃
	if (pkt->data_len == 0 && (pkt->th_flags & (TH_FIN|TH_RST)) == 0)
 		goto cleanup;

	session_desc_t *session_desc = NULL;

	session_desc = pkt_find_session_node(pkt);
	if (session_desc == NULL)//会话节点为空
	{ 
	    //当会话不存在时,首包为FIN 、RST 报文不建立会话
	    if ( pkt->data_len == 0)
	        goto cleanup;
 
		session_desc = session_node_create(pkt);
		if (session_desc == NULL)//如果创建会话节点失败，需要将报文丢弃
		{
			//printk("assert(0) session_node_create faild %p\n", session_desc);
			goto cleanup;
		}
		
		//约定会话第一个报文为上行，是客户端发出的
		pkt->direction = REQ_DIRECT;
		session_desc->req_pkt_head = pkt;
		session_desc->req_pkt_tail = pkt;
		session_desc->pkt_num = 1;
		session_desc->total_paylen = pkt->data_len;

		return;

	}
	else //存在当前会话,需要插入
	{
	    session_desc->timer_tick = now;

		/*判断报文上下行方向和结束标志*/
		if(pkt->key.dip == session_desc->key.dip)
		{
			pkt->direction = REQ_DIRECT;
			if (pkt->th_flags & TH_FIN)
				session_desc->c_fin = TRUE;        
		    else if (pkt->th_flags & TH_RST)
                session_desc->rst = TRUE;
		}
		else
		{
			pkt->direction = RSP_DIRECT;
			if (pkt->th_flags & TH_FIN)
				session_desc->s_fin = TRUE;
			else if (pkt->th_flags & TH_RST)
                session_desc->rst = TRUE;
		}
		
		insert_pkt2session(pkt, session_desc);//存在结束标志的空报文

        if(session_desc->rst ||(session_desc->c_fin && session_desc->s_fin) )
        {
            FFWD_DBG(FFWD_DBG_DEBUG, " session finished(FIN|RST) upload..\n");
      
            session_desc->stop_sec = 1;
            //print_session_node(session_desc);
			session_desc = session_node_del(session_desc);
			//ASSERT(session_desc);
			if (session_desc == NULL)
				return;
			merge_two_diections_pkt(session_desc);
			//print_merged_session_node(session_desc);	
			SMA_COUNTER_DEC(gmac1_active_sessions);
			stlc_list_add_tail(&session_desc->nd_list, &dma_list);
			return;
        }
        //printf("%s,%d\n",__FUNCTION__,__LINE__);
		//预留1600字节防止越界
		if ((session_desc->total_paylen + session_desc->pkt_num * sizeof(dma_pkt_t) 
				+ sizeof(dma_hdr_t) + 1700 >= PKT_SESSION_SIZE )||
				session_desc->pkt_num >= MAX_SESSION_PKT)//会话完成
		{
		    FFWD_DBG(FFWD_DBG_DEBUG, "Payload 8K  |packet 1024   upload..\n");
			//print_session_node(session_desc);
			session_desc = session_node_del(session_desc);
			//ASSERT(session_desc);
			if (session_desc == NULL)
				return;
			merge_two_diections_pkt(session_desc);
			//print_merged_session_node(session_desc);	
			SMA_COUNTER_DEC(gmac1_active_sessions);
			
			stlc_list_add_tail(&session_desc->nd_list, &dma_list);
			return;
		}

		return;
	}
 cleanup:
	SMA_COUNTER_INC(gmac1_session_dis_packets);
	drop_session_pkt(pkt);
	return;
	
}

//超时消息低32位为节点地址，有可能此节点已经删除，需要再次查找哈希表确认
static inline void ffwd_recv_time_out_msg(u8 code, u64 msg)
{
	session_desc_t *node = (session_desc_t *)(u32)msg;
	
    FFWD_DBG(FFWD_DBG_DEBUG, " session timeout upload..\n");
	node = session_node_del(node);
	if(node == NULL)
		return;
	print_session_node(node);
	merge_two_diections_pkt(node);
	print_merged_session_node(node);
	SMA_COUNTER_DEC(gmac1_active_sessions);
	
	if (node->pkt == NULL || node->total_paylen == 0)//如果节点没有数据报文，不应该插入到提交队列
	{
		ffwd_drop_session_node(node);
		return;
	}
	//ffwd_upload_session_pkts(node);
	stlc_list_add_tail(&node->nd_list, &dma_list);
}

//! 会话版本的UDP通道处理函数
void ffwd_udp_pkt_input(xls_packet_t *pkt, u32 ch_id)
{
	dma_hdr_t *sess_node;
	dma_pkt_t *pkt_node;
	entry_state_desc_t*rx_desc;
	u32 index;
	u32 daddr;
	u32 ret;
	
	if(rx_queue_pause[ch_id] == 0)
    {		
        FFWD_DBG(FFWD_DBG_DEBUG, "dma_dropped_udp\n");
        SMA_COUNTER_INC(gmac1_dma_dropped_udp);
        return;
    }

	if ((ffwd_dma_queue+ ch_id)->rx_dma_base == 0)
	{
	    SMA_COUNTER_INC(gmac1_dma_dropped_udp);
		return;
    }
    
	rx_desc = ffwd_udp_state_base+ ch_id * sizeof(entry_state_desc_t) * MAXNUM_UDP_ENTRY;
	spin_lock(&session_channel_lock[ch_id]);
	index = channel_offset[ch_id];
	if (rx_desc[index].state == FIFO_WRITABLE)
	{
		channel_offset[ch_id] = (index + 1) & MAXNUM_UDP_ENTRY_MASK;
	}
	else 
	{
		SMA_COUNTER_INC(gmac1_dma_dropped_udp);
		spin_unlock(&session_channel_lock[ch_id]);
		FFWD_DBG(FFWD_DBG_DEBUG, "channel[%d] full, status[%d] %d\n", 
			ch_id, index, rx_desc[index].state);
		return;//直接返回无需释放，还需要后续处理
	}
	spin_unlock(&session_channel_lock[ch_id]);
	daddr = (ffwd_dma_queue + ch_id)->rx_dma_base + index * PKT_UDP_SIZE + DMA_OFFSET;
	FFWD_DBG(FFWD_DBG_DEBUG, "channel %d daddr %#x, status[%d] %d\n", 
		ch_id, daddr, index, rx_desc[index].state);
		
	sess_node = (dma_hdr_t *)(pkt->pkt_data + PKT_RESERVE_SIZE - sizeof(dma_hdr_t));
	memset((void *)sess_node, 0, sizeof(dma_hdr_t));

	barrier();

	//构建struct dma_hdr_t
	sess_node->sip = __swab32(pkt->key.sip);
	sess_node->dip = __swab32(pkt->key.dip);
	sess_node->sport = __swab16(pkt->key.sport);
	sess_node->dport= __swab16(pkt->key.dport);
	sess_node->protocol= __swab16(pkt->protocol);
	sess_node->total_paylen = __swab16(pkt->pkt_len);
	sess_node->pkt_num= __swab16(1);
	sess_node->teid = __swab32(pkt->teid);
	
	//构建struct dma_pkt_t
	pkt_node = (dma_pkt_t *)(pkt->pkt_data + PKT_RESERVE_SIZE + pkt->pkt_len);
	
	pkt_node->sequence= __swab32(pkt->seq);
	pkt_node->ack_seq = __swab32(pkt->ack);
	pkt_node->payload_len = __swab16(pkt->data_len);
	pkt_node->data_offset = 0;
	pkt_node->direction= __swab16(pkt->direction);
    pkt_node->smac = __swab64(pkt->smac);
    pkt_node->dmac = __swab64(pkt->dmac);

	ffwd_msg_send_to_dma(TRUE, igrid_to_bucket[process_id], virt_to_phys(sess_node), 
			daddr, pkt->pkt_len + sizeof(dma_hdr_t) + sizeof(dma_pkt_t), 1, PCIE_RX_BUCKET_ID);
	ret = wait_dma_rsp_msg();
	if (ret == 0)
	{
		SMA_COUNTER_INC(gmac1_dma_udp);
		rx_desc[index].state = FIFO_READABLE;
		FFWD_DBG(FFWD_DBG_DEBUG, "channel %d, status[%d] %d\n", 
			ch_id, index, rx_desc[index].state );
	}
	return;
}


void ffwd_recv_session_msg(u32 srcid, u64 msg)
{
    xls_packet_t *pkt;
    u8 *recv_data;
    struct ip *iph;
    struct tcphdr *tcp_hdr;
    struct udphdr *udp_hdr;
    struct ether_header * eth_hdr;
    u16 ether_type;

    
    recv_data = (u8*)phys_to_virt((u32)GET_RX_MSG_DATA(msg));
    pkt = (xls_packet_t *)((u32)recv_data & MASK_2K_ALIGN);
    //预取到cache
    prefetch(Pref_Prep_For_Store, pkt);
    ((u64 *)pkt)[0] = 0;
    ((u64 *)pkt)[1] = 0;
    ((u64 *)pkt)[2] = 0;
    ((u64 *)pkt)[3] = 0;
    ((u64 *)pkt)[4] = 0;
    ((u64 *)pkt)[5] = 0;
    ((u64 *)pkt)[6] = 0;
    ((u64 *)pkt)[7] = 0;

    barrier();
#if 0
    if (GET_RX_MSG_LEN(msg) < 64 || IS_RX_MSG_ERROR(msg))
    {
        FFWD_DBG(FFWD_DBG_INFO, "pkt len too short...\n");
        goto cleanup;
    }
#endif
    pkt->data = recv_data;
    pkt->pkt_len = pkt->data_len = GET_RX_MSG_LEN(msg) - CRC_SIZE;

    //RX 统计pps bps 
    SMA_COUNTER_INC(gmac1_rx_packets);
    SMA_COUNTER_COUNT(gmac1_rx_bytes, (pkt->pkt_len + CRC_SIZE));

    //printk("pid %02d  addr %p len %u \n", process_id, recv_data, pkt->pkt_len);
    dump_mem_info(pkt->pkt_data+PKT_RESERVE_SIZE, pkt->pkt_len);
    
   	eth_hdr = (struct ether_header *)(pkt->data);
	pkt->smac = *(u64*)(eth_hdr->ether_shost)&0xffffffffffff0000ULL;
	pkt->dmac = *(u64*)(eth_hdr->ether_dhost)&0xffffffffffff0000ULL;
    pkt->data += 12; 
    pkt->data_len -= 12; 

    // 多层VLAN 标签解析
    while (*((uint16_t *) pkt->data) == ETHERTYPE_8021Q)
    {
        pkt->data += 4;
        pkt->data_len -= 4;
    }
    
    ether_type = *(uint16_t *) pkt->data ;
    pkt->data += 2;
    pkt->data_len -= 2; 

    if(ether_type != ETHERTYPE_IP)
        goto cleanup;

    //data已经指向ip header
    iph = (struct ip *)(pkt->data);
    if ((pkt->data_len < IP_HLEN)
        || (iph->ip_v != 4)
        || (iph->ip_hl < 5))
    {
        goto cleanup;
    }
    
    if ((pkt->data_len < iph->ip_len) || (pkt->data_len < (iph->ip_hl << 2)))
    {       
        goto cleanup;
    }
    

    if (pkt->data_len > iph->ip_len)//帧填充
    {
        FFWD_DBG(FFWD_DBG_DEBUG, "pkt %p trim data_len %d ip_len %d\n", pkt, pkt->data_len, iph->ip_len);
        pkt->pkt_len -= (pkt->data_len - iph->ip_len);//报文总长度需要减去帧填充长度
        pkt->data_len = iph->ip_len;
        FFWD_DBG(FFWD_DBG_DEBUG, "pkt %p after trim pkt_len %d data_len %d ip_len %d\n", 
            pkt, pkt->pkt_len, pkt->data_len, iph->ip_len);
    }
    
    if((iph->ip_off & IP_OFFMASK )||(iph->ip_off & IP_MF))
    {
        goto cleanup;
    }
    pkt->key.sip = iph->ip_src;
    pkt->key.dip = iph->ip_dst;
    pkt->protocol = iph->ip_p;

	//pkt->teid = iph->ip_sum |(iph->ip_ttl<<16)|(iph->ip_tos<<24);

    pkt->data += iph->ip_hl << 2;//skip ip header
    pkt->data_len -= iph->ip_hl << 2;
    
    
    
    if(iph->ip_p == IPPROTO_UDP)
    {
        udp_hdr = (struct udphdr *)(pkt->data);
        pkt->key.sport= udp_hdr->uh_sport;
        pkt->key.dport = udp_hdr->uh_dport;
        pkt->seq = 0;
        pkt->ack = 0;
        pkt->data += sizeof(struct udphdr);//skip udp header
        pkt->data_len -= sizeof(struct udphdr);
        SMA_COUNTER_INC(gmac1_udp_packets);
        
        pkt->hash = session_hash(&(pkt->key));
        FFWD_DBG(FFWD_DBG_DEBUG, "pkt %p data %p pkt_len %u data_len %u hash %#x seq %x, nseq %x\n", 
            pkt, pkt->data, pkt->pkt_len, pkt->data_len, pkt->hash, pkt->seq, pkt->nseq);

        ffwd_udp_pkt_input(pkt, CHANNEL_UDP);
        
        SMA_COUNTER_DEC(gmac1_session_dis_packets);
        goto cleanup;
    }
    else if(iph->ip_p == IPPROTO_TCP)
    {
        tcp_hdr = (struct tcp_hdr*)(pkt->data);
        if (tcp_hdr->th_off < 5 
            || pkt->data_len < (tcp_hdr->th_off<<2)
            || pkt->data_len < 20)
        {
            FFWD_DBG(FFWD_DBG_INFO, "tcp header len error ...\n");
            //print_pkt(pkt->pkt_data+PKT_RESERVE_SIZE, pkt->pkt_len);
            goto cleanup;
        }

        pkt->data += tcp_hdr->th_off << 2;//skip tcp header, data指针已经指向tcp payload
        pkt->data_len -= tcp_hdr->th_off << 2;
        pkt->key.sport = tcp_hdr->th_sport;
        pkt->key.dport = tcp_hdr->th_dport;

        
        pkt->th_flags = tcp_hdr->th_flags;
        pkt->seq = tcp_hdr->th_seq;
        pkt->nseq = pkt->seq + pkt->data_len;//date_len 需要除去tcp header(syn报文需要+1?)
        if (pkt->th_flags & TH_SYN)
            pkt->nseq += 1;
        pkt->ack= tcp_hdr->th_ack;
        SMA_COUNTER_INC(gmac1_tcp_packets);   
        

        pkt->hash = session_hash(&(pkt->key));
        FFWD_DBG(FFWD_DBG_DEBUG, "pkt %p data %p pkt_len %u data_len %u hash %#x seq %x, nseq %x\n", 
            pkt, pkt->data, pkt->pkt_len, pkt->data_len, pkt->hash, pkt->seq, pkt->nseq);

        ffwd_session_pkt_input(pkt);
        return ;
    }
    else 
    {
        FFWD_DBG(FFWD_DBG_DEBUG, "not tcp/udp pkt, drop...\n");
        SMA_COUNTER_INC(gmac1_dropped_packets);
        goto cleanup;
    }   
 cleanup:
    //FFWD_DBG(FFWD_DBG_DEBUG, "unkown ethernet type : 0x%04x\n", ethhdr->ether_type);
    SMA_COUNTER_INC(gmac1_session_dis_packets);
    drop_session_pkt(pkt);
    return;
    
}


int set_session_desc_for_dma(session_desc_t *node)
{
	entry_state_desc_t * rx_desc;
	u8 ch_id;
	u32 daddr;
	u32 index;
	
    ch_id = pde_vc[node->hash & 127];

	if(rx_queue_pause[ch_id] == 0)
    {
        SMA_COUNTER_INC(gmac1_dma_dropped_session);
        return ERROR;
    }
  
	rx_desc = ffwd_session_state_base + ch_id * sizeof(entry_state_desc_t) * MAXNUM_SESSION_ENTRY;
	spin_lock(&session_channel_lock[ch_id]);
	index = channel_offset[ch_id];
	if (rx_desc[index].state == FIFO_WRITABLE)
	{
		channel_offset[ch_id] = (index + 1) & (MAXNUM_SESSION_ENTRY -1);
	}
	else 
	{
		SMA_COUNTER_INC(gmac1_dma_dropped_session);
		spin_unlock(&session_channel_lock[ch_id]);
		FFWD_DBG(FFWD_DBG_DEBUG, "channel[%d] full, status[%d] %d\n", 
			ch_id, index, rx_desc[index].state);
		return ERROR;
	}
	spin_unlock(&session_channel_lock[ch_id]);
	daddr = (ffwd_dma_queue + ch_id)->rx_dma_base + index * PKT_SESSION_SIZE + DMA_OFFSET;	

	node->dma_base = daddr;//保存dma地址
	node->dma_in = index;
	node->rx_desc = rx_desc;
	node->dma_pkt = node->pkt;
	barrier();
	
	FFWD_DBG(FFWD_DBG_DEBUG, "channel[%d]: pkt->dma_base_addr %#x, status[%d] %d, new offset %u\n", 
		ch_id, node->dma_base, index, rx_desc[index].state, channel_offset[ch_id]);
	return OK;
}


void ffwd_dma_task()
{
	dma_hdr_t *node;
	
	if (dma_node == NULL)//如果当前提交节点为空(节点提交完必须置空)，从提交链表里取第一个节点，如果提交链表为空，则返回
	{	
	    
		if(stlc_list_empty(&dma_list))
		{
		    //DMA 会话列表为空直接返回 
		    return;
		}
		//从DMA 会话列表获取第一条会话
		dma_node = stlc_list_first_entry(&dma_list, session_desc_t,nd_list);
		if (set_session_desc_for_dma(dma_node) < 0)
		{
		    //如果没有取得dma目的地址(可能fifo满)，将提交节点置空，返回不提交
			stlc_list_del(&(dma_node->nd_list));//从提交链表里删除
			ffwd_drop_session_node(dma_node);
			barrier();
			dma_node = NULL;//注意必须将当前提交节点置为空,以提交下一个会话节点
			return;
		}
		
		ASSERT(dma_node->dma_base);
		ASSERT(dma_node->dma_pkt);
		ASSERT(dma_node->pkt_num);
		ASSERT(dma_node->total_paylen);
		stlc_list_del(&(dma_node->nd_list));//从提交链表里删除

        dma_pkt_array_ptr = dma_pkt_array;
        dma_node->dma_total_paylen = 0;
		//构造会话节点信息并提交
		node = (dma_hdr_t *)(dma_node->dma_pkt->pkt_data + PKT_RESERVE_SIZE - sizeof(dma_hdr_t));//第一个报文预留的64字节
		node->sip = __swab32(dma_node->key.sip);
		node->dip = __swab32(dma_node->key.dip);
		node->sport = __swab16(dma_node->key.sport);
		node->dport = __swab16(dma_node->key.dport);
		node->protocol = __swab16(dma_node->protocol);
		node->stop_sec = __swab16(dma_node->stop_sec);
		node->total_paylen = __swab16(dma_node->total_paylen);
        node->pkt_num = __swab16(dma_node->pkt_num);
        node->hash = __swab32(dma_node->hash);
		node->teid = __swab32(dma_node->teid);

        barrier();
		FFWD_DBG(FFWD_DBG_DEBUG, "dma dma_hdr_t total_paylen %u  Host_ADDR = %08x\n",
		                node->total_paylen,dma_node->dma_base);
		ffwd_msg_send_to_dma(0, igrid_to_bucket[process_id], virt_to_phys(node), 
			            dma_node->dma_base, sizeof(dma_hdr_t), 1, PCIE_RX_BUCKET_ID);
	    
		dma_node->dma_base += sizeof(dma_hdr_t);
	    return;
	}

	if (dma_node->dma_pkt)
	{	
		FFWD_DBG(FFWD_DBG_DEBUG, "dma pkt_num %u current pkt(NO:%u) , host_addr %08x\n",
			dma_node->pkt_num, dma_node->dma_pkt->de_num, dma_node->dma_base);

        barrier();
            
		ffwd_msg_send_to_dma(1, igrid_to_bucket[process_id], virt_to_phys((void *)(dma_node->dma_pkt->data)), 
		    dma_node->dma_base,dma_node->dma_pkt->data_len, 1, PCIE_RX_BUCKET_ID);
		wait_dma_rsp_msg();
		
        dma_pkt_array_ptr->sequence= __swab32(dma_node->dma_pkt->seq);
		dma_pkt_array_ptr->ack_seq = __swab32(dma_node->dma_pkt->ack);
		dma_pkt_array_ptr->payload_len = __swab16(dma_node->dma_pkt->data_len);
		dma_pkt_array_ptr->direction= __swab16(dma_node->dma_pkt->direction);
        dma_pkt_array_ptr->data_offset = __swab32(dma_node->dma_total_paylen);
        dma_pkt_array_ptr->smac = __swab64(dma_node->dma_pkt->smac);
        dma_pkt_array_ptr->dmac = __swab64(dma_node->dma_pkt->dmac);
		dma_pkt_array_ptr++;

		dma_node->dma_total_paylen +=  dma_node->dma_pkt->data_len;
		dma_node->dma_base += dma_node->dma_pkt->data_len;
		dma_node->dma_pkt = dma_node->dma_pkt->next_pkt;
		
		return;
	}
	else
	{
	    //提交各个报文的描述结构
		ffwd_msg_send_to_dma(1, igrid_to_bucket[process_id], virt_to_phys(dma_pkt_array), dma_node->dma_base,
						dma_node->pkt_num * sizeof(dma_pkt_t), 1, PCIE_RX_BUCKET_ID);
		wait_dma_rsp_msg();
	
	    SMA_COUNTER_INC(gmac1_dma_session);
		dma_node->rx_desc[dma_node->dma_in].state = FIFO_READABLE;
		FFWD_DBG(FFWD_DBG_DEBUG, "DMA Finished rx_desc[%u].state = %u\n",
		    dma_node->dma_in,dma_node->rx_desc[dma_node->dma_in].state);
		ffwd_drop_session_node(dma_node);
		barrier();
		dma_node = NULL;//注意必须将当前提交节点置为空,以提交下一个会话节点
	
		return;
	}
}

static inline void ffwd_free_time_out_msg(u64 msg)
{
	session_desc_t *node = (session_desc_t *)(u32)msg;

	node = session_node_del(node);
	if(node == NULL)
		return;
	ffwd_drop_session_node(node);
}

//拼包口接收报文入口
void ffwd_session_task()
{
	u64 msg;
	u32 srcid, size, code;
	int recv_bkt = BUCKET_RCV_PKT;
	int free_bkt = BUCKET_RCV_RSP;

	printk("pid%02d: starting session task... free_bkt = %d recv_bkt = %d\n", process_id,free_bkt,recv_bkt);

	while(1)
	{
		ffwd_dma_task();//执行dma调度
		
		if (message_receive_fast_1(free_bkt, size, code, srcid, msg) == 0) 
		{
			if (srcid == MSGRNG_STNID_CPU0) 
			{
				FFWD_DBG(FFWD_DBG_DEBUG,"srcid %u recv code %u time out msg %llx\n", srcid, code, msg);
				ffwd_recv_time_out_msg(code, msg);
			} 
			else if (srcid == PCIE_RX_BUCKET_ID)//收到dma返回消息
			{
				FFWD_DBG(FFWD_DBG_ERR,"srcid %u recv dma rsp msg %llx\n", srcid, msg);
				continue;

			}
			else 
			{
				FFWD_DBG(FFWD_DBG_ERR,"srcid %u recv unkown msg %llx\n", srcid, msg);
				continue;
			}
			continue;
		}
		
		if (message_receive_fast_1(recv_bkt, size, code, srcid, msg) == 0)
		{
			switch (srcid) 
    		{
    			case MSGRNG_STNID_GMAC1://拼包口
    				ffwd_recv_session_msg(srcid, msg);
    				continue;
    			default:
    				FFWD_DBG(FFWD_DBG_ERR, "pid %d: rcv error from %d\r\n", process_id, srcid);
    				ASSERT(0);
    		}
		}

		/* Calculate the rx rate. ycy. 2014.12.18 */
		nowtime = read_32bit_cp0_register(CP0_COUNT);
		if ((nowtime - lasttime) >= (CPU_SPEED))
		{
			ffwd_counter_info[process_id].gmac1_count_time = (nowtime - lasttime);
			/* rx_bytes + 20 bytes' lead code. */
			ffwd_counter_info[process_id].gmac1_bps = (uint64_t)((CPU_SPEED*8*((float)((ffwd_counter_info[process_id].gmac1_rx_bytes - ffwd_counter_info[process_id].gmac1_last_bytes) + 
				(ffwd_counter_info[process_id].gmac1_rx_packets - ffwd_counter_info[process_id].gmac1_last_packets) * 20))) /
				(ffwd_counter_info[process_id].gmac1_count_time));

			ffwd_counter_info[process_id].gmac1_pps = (uint64_t)((CPU_SPEED*((float)(ffwd_counter_info[process_id].gmac1_rx_packets - ffwd_counter_info[process_id].gmac1_last_packets))) /
				(ffwd_counter_info[process_id].gmac1_count_time));

			lasttime = nowtime;
			ffwd_counter_info[process_id].gmac1_last_bytes = ffwd_counter_info[process_id].gmac1_rx_bytes;
			ffwd_counter_info[process_id].gmac1_last_packets = ffwd_counter_info[process_id].gmac1_rx_packets;
		}
	}
	printk("pid%02d: thread exit\n",process_id);
	return;
	
}

void ffwd_queue_reset_check()
{
    int queue;
    
    for( queue = 0; queue < MAX_NUM_RX_CHANNELS ; queue++)
    {    
        if(ffwd_dma_queue[queue].rx_reset == 1)
        {
            //rx_dma_base[queue] = dma_queue->rx_dma_base;
            
            rx_queue_pause[queue] = 0;
            channel_offset[queue] = 0;
            ffwd_dma_queue[queue].rx_reset = 2;
            printf("reset queue %d rx_queue_pause = %d channel_offset =%u rx_reset=%u %08x\n",
                queue,rx_queue_pause[queue],channel_offset[queue],ffwd_dma_queue[queue].rx_reset
                ,ffwd_dma_queue[queue].rx_dma_base);
            barrier();
        }
        else if(ffwd_dma_queue[queue].rx_reset == 3)
        {
            rx_queue_pause[queue] = 1;
            ffwd_dma_queue[queue].rx_reset = 0;
            printf("queue %d open rx_queue_pause=%d channel_offset =%u rx_reset=%d\n",
                queue,rx_queue_pause[queue],channel_offset[queue],ffwd_dma_queue[queue].rx_reset);
            barrier();
        }
    }
}

void ffwd_link_status()
{
	phoenix_reg_t * mmio = phoenix_io_mmio(PHOENIX_IO_GMAC_0_OFFSET);
	uint8_t status = (xmdio_read(mmio,1,0,1)&0x4)&(xmdio_read(mmio,3,0,1)&0x4)&(xmdio_read(mmio,4,0,1)&0x4);
	
	if(status != ffwd_mac_device_info->link)
	{
		ffwd_mac_device_info->link = status;
		ffwd_mac_interrupt_host();
	}
		
}
static uint8_t promisc_mode = 0;

void ffwd_promisc_status()
{
	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_GMAC_0_OFFSET);
	
	if (promisc_mode != ffwd_mac_device_info->promisc)
	{
		promisc_mode = ffwd_mac_device_info->promisc;
		if (ffwd_mac_device_info->promisc)
		{
			turn_off_filtering(mmio);
			printk("gmac0 open promisc mode\n");
		}
		else
		{
			turn_on_filtering(mmio);
			printk("gmac0 close promisc mode\n");
		}

	    barrier();
	}
}


void ffwd_scan_task()
{
	u64 msg;
	int i;
	u32 start, tick=0, start2 = 0, tick2 = 0;
	
	//由于0号线程用于bootloader shell暂时没有启用，分配的哈希桶未能做初始化，因此不能对此空间扫描 
	struct stlc_hlist_head *base = (struct stlc_hlist_head *)(SESSION_BKT_BASE + MAXNUM_FLOW_BUCKET * sizeof(struct stlc_hlist_head));
	struct stlc_hlist_node *tmp = NULL, *tmp2 = NULL;
	session_desc_t *entry = NULL;

	//printk("pid %02d : starting scan task, time_out %llx base %p\n", process_id, time_out, base);
	now = 0;

	tick2 = start = read_32bit_cp0_register(CP0_COUNT);
	while(1)
	{
		tick = read_32bit_cp0_register(CP0_COUNT) ;
		now += (tick-start);
		start = tick;

		for (i=0; i<MAXNUM_FLOW_BUCKET * (MAXNUM_VCPU-1); i++) //session node desc
		{
			spin_lock((spinlock_t *)&(base[i].lock));
			stlc_hlist_for_each_entry_safe(entry, tmp, tmp2, &base[i], nd_hlist) 
			{
				if (now - entry->timer_tick >= time_out)
				{
					if (entry->timeout == FALSE) 
					{
						msg = FMN_MAKE_TIME_OUT_MSG(entry);
						barrier();
		
						if (ffwd_message_send_code_1(FMN_MSG_CODE_TIMEOUT, igrid_to_bucket[entry->pid], msg) != 0) 
						{
							FFWD_DBG(FFWD_DBG_DEBUG, "pid %02d send to bkt %u err  msg %16llx\n", process_id,igrid_to_bucket[entry->pid], msg);
						} 
						else 
						{
							entry->timeout = TRUE;
							//FFWD_DBG(FFWD_DBG_DEBUG, "pid %02d send to bkt %u ok  msg %16llx\n", process_id,igrid_to_bucket[entry->pid], msg);
						}
					}
				}
			}
			spin_unlock((spinlock_t *)&(base[i].lock));
		}

		tick2 = read_32bit_cp0_register(CP0_COUNT);

		if (tick2 - start2 >= CPU_SPEED)
		{
		    if(ffwd_device_info->cmd_state == CMD_STATE_NEW)
		    {
		        if(ffwd_device_info->cmd_type == CMD_XAUI_OPEN)
		        {
		            rmi_xaui_open(0);
		            rmi_xaui_open(4);
		        }    
		        if(ffwd_device_info->cmd_type == CMD_XAUI_CLOSE)
		        {
		            rmi_xaui_close(0);
		            rmi_xaui_close(4);
                }
		        ffwd_device_info->cmd_state = CMD_STATE_DONE;   
		    }

            //流超时时间
            if(ffwd_device_info->timeout_value != time_out/CPU_SPEED)
            {
                time_out = ffwd_device_info->timeout_value * CPU_SPEED;
                printk("session timeout value %d (s)\r\n",time_out/CPU_SPEED);
            }

            ffwd_promisc_status();
            
			ffwd_link_status();
            //接收队列分发向量检查
            ffwd_pde_vc_update();

			ffwd_queue_reset_check();
			
			start2 = tick2;

            phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_GMAC_0_OFFSET);
            uint32_t rx = phoenix_read_reg(mmio,G_RPKT);
            uint32_t tx = phoenix_read_reg(mmio,G_TPKT);
            printk("rx packet(%u) tx packet(%u)\n",rx,tx); 
            
             
		}
		
	}
	printk("pid%02d: thread exit\n",process_id);
}


